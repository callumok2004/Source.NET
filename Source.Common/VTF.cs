using Source.Common.Filesystem;
using Source.Common.MaterialSystem;

using System.Drawing;
using System.Numerics;

namespace Source.Common;


public enum CompiledVtfFlags : ulong
{
	// flags from the *.txt config file
	PointSample = 0x00000001,
	Trilinear = 0x00000002,
	ClampS = 0x00000004,
	ClampT = 0x00000008,
	Anisotropic = 0x00000010,
	HintDXT5 = 0x00000020,
	SRGB = 0x00000040,
	Normal = 0x00000080,
	NoMip = 0x00000100,
	NoLOD = 0x00000200,
	AllMips = 0x00000400,
	Procedural = 0x00000800,

	// These are automatically generated by vtex from the texture data.
	OneBitAlpha = 0x00001000,
	EightBitAlpha = 0x00002000,

	// newer flags from the *.txt config file
	TEnvMap = 0x00004000,
	TRenderTarget = 0x00008000,
	TDepthRenderTarget = 0x00010000,
	TNoDebugOverride = 0x00020000,
	TSingleCopy = 0x00040000,

	StagingMemory = 0x00080000,
	ImmediateCleanup = 0x00100000,
	IgnorePicmip = 0x00200000,

	UNUSED_00400000 = 0x00400000,

	NoDepthBuffer = 0x00800000,

	UNUSED_01000000 = 0x01000000,

	ClampU = 0x02000000,

	VertexTexture = 0x04000000,                    // Useable as a vertex texture

	SSBump = 0x08000000,

	UNUSED_10000000 = 0x10000000,

	// Clamp to border color on all texture coordinates
	Border = 0x20000000,

	StreamableCourse = 0x40000000,
	StreamableFine = 0x80000000,
	Streamable = (StreamableCourse | StreamableFine)
}

public enum VersionedVtfFlags : ulong
{
	VERSIONED_VTF_FLAGS_MASK_7_3 = ~0xD1780400, // For a ver 7.3 or earlier only these flags are valid
}

public enum CubeMapFaceIndex
{
	Right,
	Left,
	Back,
	Front,
	Up,
	Down,
	Spheremap
}

public enum LookDir
{
	X,
	NegX,
	Y,
	NegY,
	Z,
	NegZ
}

public interface IVTFTexture
{
	bool Init(int width, int height, int depth, ImageFormat format, int flags, int frameCount, int forceMipCount = -1);

	void SetBumpScale(float scale);
	void SetReflectivity(in Vector3 vecReflectivity);
	void InitLowResImage(int width, int height, ImageFormat format);
	Span<byte> SetResourceData(uint type, Span<byte> data);
	Span<byte> GetResourceData(uint type);
	bool HasResourceEntry(uint type);

	bool Unserialize(Stream stream, bool headerOnly = false, int skipMipLevels = 0);
	bool Serialize(Stream stream);

	// These are just utils for unserializing/deserializing from filesystem handles directly.
	// Which might be nice because it does null value checking, and also checks CanRead/Write status on the stream itself
	bool Unserialize(IFileHandle? handle, bool headerOnly = false, int skipMipLevels = 0) 
		=> handle != null && handle.Stream.CanRead && Unserialize(handle.Stream, headerOnly, skipMipLevels);
	bool Serialize(IFileHandle? handle) 
		=> handle != null && handle.Stream.CanWrite && Serialize(handle.Stream);

	// Yes, ideally, we would have nint's. But a lot of .NET uses ints, and Span<byte>'s are no exception
	void LowResFileInfo(out int startLocation, out int sizeInBytes);
	void ImageFile(int frame, int face, int mip, out int startLocation, out int sizeInBytes);
	int FileSize(int mipSkipCount = 0);

	int Width();
	int Height();
	int Depth();
	int MipCount();

	int RowSizeInBytes(int mipLevel);
	int FaceSizeInBytes(int mipLevel);

	ImageFormat Format();
	int FaceCount();
	int FrameCount();
		int Flags();

	float BumpScale();

	int LowResWidth();
	int LowRetHeight();
	ImageFormat LowResFormat();

	ReadOnlySpan<Vector3> Reflectivity();

	bool IsCubeMap();
	bool IsNormalMap();
	bool IsVolumeTexture();

	void ComputeMipLevelDimensions(int level, out int width, out int height, out int depth);
	int ComputeMipSize(int mipLevel);
	void ComputeMipLevelSubRect(Rectangle srcRect, int mipLevel, out Rectangle subRect);
	int ComputeFaceSize(int startingMipLevle = 0);
	int ComputeTotalSize();

	Span<byte> ImageData();
	Span<byte> ImageData(int frame, int face, int mipLevel);
	Span<byte> ImageData(int frame, int face, int mipLevel, int x, int y, int z = 0);
	Span<byte> LowResImageData();
	
	void ConvertImageFormat(ImageFormat format, bool normalToDUDV);
	void GenerateSpheremap(LookDir lookDir = LookDir.Z);
	void GenerateHemisphereMap(Span<byte> sphereMapBitsRGBA, int targetWidth, int targetHeight, LookDir lookDir, int frame);
	void FixCubemapFaceOrientation();
	void GenerateMipmaps();
	void PutOneOverMipLevelInAlpha();

	void ComputeReflectivity();
	void ComputeAlphaFlags();
	void ConstructLowResImage();

	void PostProcess(bool generateSpheremap, LookDir lookDir = LookDir.Z, bool allowFixCubemapOrientation = true);
	void MatchCubeMapBorders(int stage, ImageFormat finalFormat, bool skybox);
	void SetAlphaTestThresholds(float baseThreshold, float highFreq);
	// do the rest later. Already defining more than we need right now

	public const int VTF_MAJOR_VERSION = 7;
	public const int VTF_MINOR_VERSION = 4;
}