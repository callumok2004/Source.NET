using Source.Common.Bitmap;
using Source.Common.Filesystem;

using System.Drawing;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace Source.Common;


public enum CompiledVtfFlags : uint
{
	// flags from the *.txt config file
	PointSample = 0x00000001,
	Trilinear = 0x00000002,
	ClampS = 0x00000004,
	ClampT = 0x00000008,
	Anisotropic = 0x00000010,
	HintDXT5 = 0x00000020,
	SRGB = 0x00000040,
	Normal = 0x00000080,
	NoMip = 0x00000100,
	NoLOD = 0x00000200,
	AllMips = 0x00000400,
	Procedural = 0x00000800,

	// These are automatically generated by vtex from the texture data.
	OneBitAlpha = 0x00001000,
	EightBitAlpha = 0x00002000,

	// newer flags from the *.txt config file
	EnvMap = 0x00004000,
	RenderTarget = 0x00008000,
	DepthRenderTarget = 0x00010000,
	NoDebugOverride = 0x00020000,
	SingleCopy = 0x00040000,

	StagingMemory = 0x00080000,
	ImmediateCleanup = 0x00100000,
	IgnorePicmip = 0x00200000,

	UNUSED_00400000 = 0x00400000,

	NoDepthBuffer = 0x00800000,

	UNUSED_01000000 = 0x01000000,

	ClampU = 0x02000000,

	VertexTexture = 0x04000000,                    // Useable as a vertex texture

	SSBump = 0x08000000,

	UNUSED_10000000 = 0x10000000,

	// Clamp to border color on all texture coordinates
	Border = 0x20000000,

	StreamableCourse = 0x40000000,
	StreamableFine = 0x80000000,
	Streamable = (StreamableCourse | StreamableFine)
}

public enum VersionedVtfFlags : ulong
{
	Mask_7_3 = ~0xD1780400, // For a ver 7.3 or earlier only these flags are valid
}

public enum CubeMapFaceIndex
{
	Right,
	Left,
	Back,
	Front,
	Up,
	Down,
	Spheremap,
		Count
}

public enum LookDir
{
	X,
	NegX,
	Y,
	NegY,
	Z,
	NegZ
}

public interface IVTFTexture : IDisposable
{
	bool Init(int width, int height, int depth, ImageFormat format, int flags, int frameCount, int forceMipCount = -1);

	void SetBumpScale(float scale);
	void SetReflectivity(in Vector3 vecReflectivity);
	void InitLowResImage(int width, int height, ImageFormat format);
	Span<byte> SetResourceData(uint type, Span<byte> data);
	Span<byte> GetResourceData(uint type);
	bool HasResourceEntry(uint type);

	bool Unserialize(Stream stream, bool headerOnly = false, int skipMipLevels = 0);
	bool Serialize(Stream stream);

	// These are just utils for unserializing/deserializing from filesystem handles directly.
	// Which might be nice because it does null value checking, and also checks CanRead/Write status on the stream itself
	bool Unserialize(IFileHandle? handle, bool headerOnly = false, int skipMipLevels = 0)
		=> handle != null && handle.Stream.CanRead && Unserialize(handle.Stream, headerOnly, skipMipLevels);
	bool Serialize(IFileHandle? handle)
		=> handle != null && handle.Stream.CanWrite && Serialize(handle.Stream);

	// Yes, ideally, we would have nint's. But a lot of .NET uses ints, and Span<byte>'s are no exception
	void LowResFileInfo(out int startLocation, out int sizeInBytes);
	void ImageFileInfo(int frame, int face, int mip, out int startLocation, out int sizeInBytes);
	int FileSize(int mipSkipCount = 0);

	int Width();
	int Height();
	int Depth();
	int MipCount();

	int RowSizeInBytes(int mipLevel);
	int FaceSizeInBytes(int mipLevel);

	ImageFormat Format();
	int FaceCount();
	int FrameCount();
	int Flags();

	float BumpScale();

	int LowResWidth();
	int LowResHeight();
	ImageFormat LowResFormat();

	Vector3 Reflectivity();

	bool IsCubeMap();
	bool IsNormalMap();
	bool IsVolumeTexture();

	void ComputeMipLevelDimensions(int level, out int width, out int height, out int depth);
	int ComputeMipSize(int mipLevel);
	void ComputeMipLevelSubRect(Rectangle srcRect, int mipLevel, out Rectangle subRect);
	int ComputeFaceSize(int startingMipLevle = 0);
	int ComputeTotalSize();

	Span<byte> ImageData();
	Span<byte> ImageData(int frame, int face, int mipLevel);
	Span<byte> ImageData(int frame, int face, int mipLevel, int x, int y, int z = 0);
	Span<byte> LowResImageData();

	void ConvertImageFormat(ImageFormat format, bool normalToDUDV);
	void GenerateMipmaps();

	void ComputeReflectivity();
	void ComputeAlphaFlags();
	void ConstructLowResImage();

	public const int VTF_MAJOR_VERSION = 7;
	public const int VTF_MINOR_VERSION = 4;

	// Implementation of VTF can add these factory methods.
	public static event CreateVTFTextureDelegate? OnCreate;
	public static event DestroyVTFTextureDelegate? OnDestroy;
	public static event VTFFileHeaderSizeDelegate? OnRequestSize;

	public static IVTFTexture Create() {
		if (OnCreate == null)
			throw new NotImplementedException("No VTF factory available");
		return OnCreate.Invoke();
	}
	public static void Destroy(IVTFTexture texture) {
		if (OnDestroy == null)
			throw new NotImplementedException("No VTF factory available");
		OnDestroy.Invoke(texture);
	}
	public static ushort FileHeaderSize(int majorVersion = -1, int minorVersion = -1) {
		if (OnRequestSize == null)
			throw new NotImplementedException("No VTF factory available");
		return OnRequestSize.Invoke(majorVersion, minorVersion);
	}
}
// Factory methods
public delegate IVTFTexture CreateVTFTextureDelegate();
public delegate void DestroyVTFTextureDelegate(IVTFTexture texture);
public delegate ushort VTFFileHeaderSizeDelegate(int majorVersion, int minorVersion);

public class VTFFileBaseHeader
{
	public readonly sbyte[] FileTypeString = new sbyte[4];
	public readonly int[] Version = new int[2];
	public uint HeaderSize = 0;

	public static readonly ushort Size = 
		4 // FileTypeString 
		+ (2 * sizeof(int)) // Version 
		+ sizeof(uint) // HeaderSize
		;
}

public class VTFFileHeaderV7_1 : VTFFileBaseHeader {
	public ushort Width;
	public ushort Height;
	public uint Flags;
	public ushort NumFrames;
	public ushort StartFrame;
	public Vector3 Reflectivity;
	public float BumpScale;
	public ImageFormat ImageFormat;
	public byte NumMipLevels;
	public ImageFormat LowResImageFormat;
	public byte LowResImageWidth;
	public byte LowResImageHeight;

	public static new readonly ushort Size = (ushort)(VTFFileBaseHeader.Size
		+ sizeof(ushort) // Width
		+ sizeof(ushort) // Height
		+ sizeof(uint) // Flags
		+ sizeof(ushort) // NumFrames
		+ sizeof(ushort) // StartFrame
		+ (sizeof(float) * 3) // Reflectivity
		+ sizeof(float) // BumpScale
		+ sizeof(ImageFormat) // ImageFormat
		+ sizeof(byte) // NumMipLevels
		+ sizeof(ImageFormat) // LowResImageFormat
		+ sizeof(byte) // LowResImageWidth
		+ sizeof(byte) // LowResImageHeight
		);
}

public class VTFFileHeaderV7_2 : VTFFileHeaderV7_1
{
	public ushort Depth;

	public static new readonly ushort Size = (ushort)(VTFFileHeaderV7_1.Size 
		+ sizeof(ushort) // Depth
		);
}

public class VTFFileHeaderV7_3 : VTFFileHeaderV7_2
{
	public readonly sbyte[] Pad4 = new sbyte[3];
	public uint NumResources;
	public long ResourcesOffset; // The offset into the stream where we can read resource data later

	public static new readonly ushort Size = (ushort)(VTFFileHeaderV7_2.Size
		+ (sizeof(sbyte) * 3) // Pad4
		+ sizeof(uint) // NumResources
		);
}

public class VTFFileHeader : VTFFileHeaderV7_3
{

}

public enum HeaderDetails : short {
	MaxRSRCDictionaryEntries = 32
}

public struct ResourceEntryInfo
{
	public static ref ResourceEntryInfo NULL => ref Unsafe.NullRef<ResourceEntryInfo>();
	public ResourceEntryType Tag;
	public byte Flags;
	public uint Offset;

	public static ResourceEntryType ParseTag(byte byte1, byte byte2, byte byte3) {
		return (ResourceEntryType)((byte1 << 16) + (byte2 << 8) + byte3);
	}
}

public enum ResourceEntryType
{
	/// <summary>
	/// Equiv of VTF_LEGACY_RSRC_LOW_RES_IMAGE
	/// </summary>
	LowResThumbnail = 0x00010000,
	/// <summary>
	/// Equiv of VTF_LEGACY_RSRC_IMAGE
	/// </summary>
	HighResImageData = 0x00300000,
	/// <summary>
	/// Equiv of VTF_RSRC_SHEET (i think?)
	/// </summary>
	AnimatedParticleSheetData = 0x00100000,


	/// <summary>
	/// Equiv of VTF_RSRC_TEXTURE_CRC (i think?)
	/// </summary>
	CRC = 0x00435243,
	/// <summary>
	/// Equiv of VTF_RSRC_TEXTURE_LOD_SETTINGS (i think?)
	/// </summary>
	TextureLOD = 0x004c4f44,
	/// <summary>
	/// Equiv of VTF_RSRC_TEXTURE_SETTINGS_EX (i think?)
	/// </summary>
	Extended = 0x0054534f,
	// Wait, what is this for...
	// KeyValueData = 0x004b5644
}

public struct TextureLODControlSettings {
	public byte ResolutionClampX;
	public byte ResolutionClampY;
	// unused
	public byte ResolutionClampX_360;
	public byte ResolutionClampY_360;
}

public struct TextureSettingsEx {
	public byte Flags0;
	public byte Flags1;
	public byte Flags2;
	public byte Flags3;
}

public struct TextureStreamSettings_t {
	public byte FirstAvailableMip;
	public byte LastAvailableMip;
	public byte Reserved0;
	public byte Reserved1;
}